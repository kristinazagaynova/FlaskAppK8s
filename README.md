# FlaskAppK8s
# Лабораторная работа №2 "Работа с Kubernetes"

## Задание:
1.Создать веб приложение “hello world” на любом языке программирования, которое должно работать на порту 32777;
2.Установить Docker на рабочий компьютер;
3.Собрать контейнер с вашим приложением и опубликовать его на Docker Hub;
4.Установить Minikube используя оригинальную инструкцию. После установки необходимо развернуть minikube cluster;
5.Вам необходимо создать deployment с 2 репликами вашего приложения;
6.Создать сервис, через который у вас будет доступ на эти "поды". Выбор типа сервиса остается на ваше усмотрение;
7.Запустить в minikube режим проброса портов и подключиться к вашим контейнерам через веб браузер;
8.Опубликовать работу в открытом гит репозитории;
9.Приложить ссылку на гит репозиторий, схему организации контейнеров и сервисов(draw.io) и скриншоты с результатами работы;

## Ход работы

Для работы нам потребуются:

- Docker Engine – для создания образа Docker и контейнеров
- kuberctl – для запуска команд для кластеров Kubernetes
- Minikube – для запуска Kubernetes на локальной машине
### Создание приложения
Напишем простое веб-приложение, работающее на порту 32777 при помощи серверного фреймворка Flask, и проверим его работоспособность и доступность. 
<br>![](./img/1.jpg)<br/>
### Создание образа
Установим Docker и соберем контейнер с нашим приложением. Для этого напишем Dockerfile, в котором установим необходимые зависимости и пропишем команду для запуска. 

```
FROM python:3.9
RUN pip install flask
COPY app.py /app
CMD ["python", "app.py"]
```
Опубликуем его на DockerHub.
<br>![](./img/2.jpg)<br/>

### Работа с minikube

Создадим кластер minikube

> minikube start
<br>![](./img/3.jpg)<br/>

Создадим YAML-файл, в котором опишем Deployment – ресурс Kubernetes, предназначенный для развертывания приложений и их обновления декларативным образом. 

```

apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: app
  template:
    metadata:
      labels:
        app: app
    spec:
      containers:
      - name: app
        image: kristinazagaynova/myflaskapp
        ports:
        - containerPort: 32777


```

В кофигурационном файле мы задали количество реплик (2 штуки) и метки для подов, соответствующих шаблону.

Применим конфигурационный файл развертывания:

> kubectl apply -f deployment.yaml

По умолчанию под доступен только при обращении по его внутреннему IP-адресу внутри кластера Kubernetes. Чтобы сделать контейнер доступным вне виртуальной сети Kubernetes, необходимо представить под как Service Kubernetes. Создадим YAML-файл, в котором его опишем

```

apiVersion: v1
kind: Service
metadata: 
  name: app-service
spec:
  selector:   
    app: app
  type: NodePort
  ports: 
    - name: http
      protocol: TCP
      port: 32777
      targetPort: 32777
      nodePort: 30036

```

Возьмем тип сервиса NodePort, поскольку он простот в настройке и использовании, а необходимости в масштабировании или равномерном распределении нагрузки у нас нет

Применим:

> kubectl apply -f service.yaml

### Проверка работоспособности

Запустим сервис.

> minikube service weatherapp-service
<br>![](./img/3.jpg)<br/>

Откроем браузер. Ура, все работает!
<br>![](./img/4.gif)<br/>
